package ie.setu.scouting.event

import android.app.Activity
import android.app.DatePickerDialog
import android.os.Bundle
import android.view.Menu
import android.view.MenuItem
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.snackbar.Snackbar
import ie.setu.scouting.R
import ie.setu.scouting.databinding.ActivityEventBinding
import ie.setu.scouting.main.MainApp
import ie.setu.scouting.models.EventModel
import timber.log.Timber.i
import java.time.LocalDate
import java.time.format.DateTimeFormatter

class EventActivity : AppCompatActivity() {
    // CHATGPT CREATED this companion object
    private companion object {
        const val STATE_TITLE = "state_title"
        const val STATE_DESC = "state_desc"
        const val STATE_LEADERS = "state_leaders"
        const val STATE_PARENTS = "state_parents"
        const val STATE_DATE = "state_date"
        const val STATE_EDITMODE = "state_editmode"
        const val STATE_EVENT_ID = "state_event_id"
    }
    private lateinit var binding: ActivityEventBinding
    private lateinit var app: MainApp

    private var event = EventModel()
    private var editMode = false

    private val dateFormatter = DateTimeFormatter.ofPattern("dd MMM yyyy")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityEventBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Toolbar
        binding.toolbarAdd.title = title
        setSupportActionBar(binding.toolbarAdd)

        // App reference
        app = application as MainApp
        i("Event Activity started...")

        binding.btnDelete.visibility = View.GONE

        if (intent.hasExtra("event_edit")) {
            editMode = true
            //event = intent.extras?.getParcelable("event_edit")!! This was the original I was trying to work with
            //I used ChatGPT to find a working version as the above was depreciated.
            if (intent.hasExtra("event_edit")) {
                @Suppress("DEPRECATION")
                event = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
                    intent.getParcelableExtra("event_edit", EventModel::class.java)!!
                } else {
                    intent.getParcelableExtra<EventModel>("event_edit")!!
                }
            }

            savedInstanceState?.let { state ->
                editMode = state.getBoolean(STATE_EDITMODE, editMode)
                if (editMode) {
                    val restoredId = state.getLong(STATE_EVENT_ID, event.id)
                    event.id = restoredId
                }
                binding.eventTitle.setText(
                    state.getString(STATE_TITLE, binding.eventTitle.text?.toString() ?: "")
                )
                binding.description.setText(
                    state.getString(STATE_DESC, binding.description.text?.toString() ?: "")
                )
                binding.leadersNeeded.setText(
                    state.getString(STATE_LEADERS, binding.leadersNeeded.text?.toString() ?: "")
                )
                binding.parentVolunteersAllowed.isChecked =
                    state.getBoolean(STATE_PARENTS, binding.parentVolunteersAllowed.isChecked)
                binding.eventDate.setText(
                    state.getString(STATE_DATE, binding.eventDate.text?.toString() ?: "")
                )
            } //As with other bundling this was generated by Chatgpt

            binding.btnAdd.text = getString(R.string.button_save_event)

            binding.btnDelete.visibility = View.VISIBLE
            binding.btnDelete.setOnClickListener {
                app.events.delete(event)
                setResult(Activity.RESULT_OK)
                finish()
            }
        } else {
            binding.btnAdd.text = getString(R.string.button_add_event)
        }


        val openDatePicker = {
            val initialDate = if (!binding.eventDate.text.isNullOrEmpty()) {
                runCatching { LocalDate.parse(binding.eventDate.text.toString(), dateFormatter) }
                    .getOrElse { LocalDate.now() }
            } else {
                LocalDate.now()
            }

            val year = initialDate.year
            val monthZeroBased = initialDate.monthValue - 1
            val day = initialDate.dayOfMonth

            DatePickerDialog(this, { _, y, m, d ->
                val picked = LocalDate.of(y, m + 1, d)
                binding.eventDate.setText(picked.format(dateFormatter))
            }, year, monthZeroBased, day).show()
        }

        binding.eventDate.setOnClickListener { openDatePicker() }
        //Date picker implementation was helped by ChatGPT
        //However ChatGPT was unable to recognize that data picker itself was selectable and did not need
        //a button. So the prompt was useful for groundwork code but unable to effectively contribute
        // implenting it into the UI

        binding.btnAdd.setOnClickListener { v ->
            event.title = binding.eventTitle.text.toString()
            event.description = binding.description.text.toString()
            event.leadersNeeded = binding.leadersNeeded.text.toString().toInt() // or toIntOrNull() ?: 0
            event.parentVolunteersAllowed = binding.parentVolunteersAllowed.isChecked
            event.date = binding.eventDate.text.toString()

            if (event.title.isNotEmpty()) {
                if (editMode) {
                    app.events.update(event)
                } else {
                    app.events.create(event.copy())
                }
                setResult(Activity.RESULT_OK)
                finish()
            } else {

                Snackbar.make(
                    v,
                    getString(R.string.snackbar_enter_title),
                    Snackbar.LENGTH_LONG
                ).show()
            }
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.menu_event, menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == R.id.item_cancel) {
            finish()
            return true
        }
        return super.onOptionsItemSelected(item)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putString(STATE_TITLE, binding.eventTitle.text?.toString() ?: "")
        outState.putString(STATE_DESC, binding.description.text?.toString() ?: "")
        outState.putString(STATE_LEADERS, binding.leadersNeeded.text?.toString() ?: "")
        outState.putBoolean(STATE_PARENTS, binding.parentVolunteersAllowed.isChecked)
        outState.putString(STATE_DATE, binding.eventDate.text?.toString() ?: "")
        outState.putBoolean(STATE_EDITMODE, editMode)
        outState.putLong(STATE_EVENT_ID, event.id)
    } // GENERATED by ChatGPT
}
